% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}



\title{ENCORE Documentation}
\date{March 09, 2015}
\release{1.0}
\author{}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{index:introduction}\label{index:welcome-to-encore-s-documentation}
ENCORE is a Python package designed to quantify the similarity between
conformational ensembles of proteins (or in principle other
macromolecules), using three different methods originally described
in:

\begin{Verbatim}[frame=single,commandchars=\\\{\}]
Kresten Lindorff\PYGZhy{}Larsen, Jesper Ferkinghoff\PYGZhy{}Borg (2009)
Similarity Measures for Protein Ensembles.
PLoS ONE 4(1): e4203. doi:10.1371/journal.pone.0004203
\end{Verbatim}

A description of ENCORE and a number of application can be found in:

\begin{Verbatim}[frame=single,commandchars=\\\{\}]
Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma and
Kresten Lindorff\PYGZhy{}Larsen,
ENCORE: Software for quantitative ensemble comparison
Submitted
\end{Verbatim}

The package includes facilities for handling ensembles and
trajectories, performing clustering or dimensionality reduction of the
ensemble space, estimating multivariate probability distributions from
the input data, and more. ENCORE can be used to compare experimental
and simulation-derived ensembles, as well as estimate the convergence
of trajectories from time-dependent simulations. The package was
designed as a Python 2.6 (or any higher 2.X version) library. The user
may also use some of the library files as scripts that accept command
line arguments. Usually, the help text included for each script
(obtained running “python encore/script.py -h”) is
self-explanatory. Examples are also available on how ENCORE may be
used to calculate the similarity measures on a number of ensembles.

The similarity measures implemented in ENCORE are based on three
different methods, which all rely on the following idea: Given two or
more conformational ensembles of the same topology (i.e. structure),
we view the particular set of conformations from each ensemble as a
sample from an underlying, but unknown, probability distribution. We
use this sample to model the probability density function of said
distribution. Then we compare the modeled distributions using standard
measures of the similarity between two probability densities, such as
the Jensen-Shannon divergence.

In the ENCORE package, we have implemented three methods to estimate
the density:
\begin{itemize}
\item {} 
Harmonic ensembles similarity (HES): we assume that each ensemble is
derived from a multivariate normal distribution. We, thus, estimate
the parameters for the distribution of each ensemble (mean and
covariance matrix) and compare them using a symmetrized version of
the Kullback-Leibler divergence. For each ensemble, the mean
conformation is estimated as the average over the ensemble, and the
covariance matrix is calculated by default using a shrinkage
estimate method (or by a maximum-likelihood method, optionally).

\item {} 
Clustering-based similarity (CES): We use the affinity propagation
method for clustering to partition the whole space of conformations
in to clusters of structures. After the structures are clustered we
take the population of each ensemble in each cluster as a
probability distribution of conformations. We then compare the
obtained probability distribution using the Jensen-Shannon
divergence measure between probability distributions.

\item {} 
Dimensionality reduction-based similarity (DRES): We use a gaussian
kernel-based density estimation method to estimate the probability
density, and use that as probability function in order to compare
different ensembles. Before doing that, however, due to the limited
size of the sample, it is necessary to reduce the dimensionality of
the input space. Thus, the method first projects the ensembles into
lower dimensions by using the Stochastic Proximity Embedding
algorithm.

\end{itemize}

ENCORE is able to use, as input data, structural ensembles deriving
both from molecular simulations (e.g. molecular dynamics or Monte
Carlo methods) or experimental structural ensembles (e.g. NMR
structures as PDB files). The software is able to handle the most
popular trajectory formats (files such as DCD, XTC, TRR, XYZ, TRJ,
MDCRD), although periodic boundaries conditions must be removed before
use. A topology file is also required.

Together with the software, we also provide three examples that
showcase three typical cases of study:
\begin{itemize}
\item {} 
comparing simulation trajectories with other trajectories

\item {} 
estimating convergence of trajectories from molecular dynamics simulations

\item {} 
comparing  experimentally-derived ensembles from the PDB

\end{itemize}

See the examples themselves for more information.
If you use ENCORE for your scientific work, please cite:

\begin{Verbatim}[frame=single,commandchars=\\\{\}]
Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma
and Kresten Lindorff\PYGZhy{}Larsen,
ENCORE: Software for quantitative ensemble comparison
Submitted
\end{Verbatim}


\chapter{encore package}
\label{index:encore-package}

\section{Submodules}
\label{index:submodules}

\section{encore.Ensemble module}
\label{index:module-encore.Ensemble}\label{index:encore-ensemble-module}\index{encore.Ensemble (module)}

\subsection{Ensemble representation --- \texttt{MDAnalysis.analysis.ensemble.ensemble}}
\label{index:ensemble-representation-mdanalysis-analysis-ensemble-ensemble}
This module contains the Ensemble class allowing for easy reading in 
and alignment of the ensemble contained in one or more trajectory files.
Trajectory files can be specified in several formats, including the popular
xtc and dcd, as well as experimental multiple-conformation pdb files, i.e.
those coming from NMR structure resoltion experiments.
\index{Ensemble (class in encore.Ensemble)}

\begin{fulllineitems}
\phantomsection\label{index:encore.Ensemble.Ensemble}\pysiglinewithargsret{\strong{class }\code{encore.Ensemble.}\bfcode{Ensemble}}{\emph{universe=None}, \emph{topology=None}, \emph{trajectory=None}, \emph{atom\_selection\_string='(name CA)'}, \emph{superimposition\_selection\_string=None}, \emph{frame\_interval=1}}{}
Ensemble class designed to easily manage more than one trajectory files. Users can provide either a topology/trajectory(es) combination or a MDAnalysis.Universe object. Topology and trajectory files must have the same number of atoms, and order is of course important.

While creating a new Ensemble object it is possible to load from a trajectory a selected subset of atoms, using the MDAnalysis syntax for selections (see \href{http://mdanalysis.googlecode.com/git/package/doc/html/documentation\_pages/selections.html}{http://mdanalysis.googlecode.com/git/package/doc/html/documentation\_pages/selections.html} for details) and the atom\_selection\_string argument. By default all the alpha carbons (``CA'') are considered. It is also possible to load a lower number of frames for each trajectory, by selecting only one frame every frame\_interval (e.g. with frame-interval=2 only every second frame will be loaded).

Frames in an Ensemble object can be superimposed to a reference conformation (see method align). By default the rotation matrix for this superimposition is calculated on all the atoms of the system, as defined by the atom\_selection\_string. However, if the superimposition\_selection\_string is provided, that subset will be used to calculate the rotation matrix, which will be applied on the whole atom\_selection\_string. Notice that the set defined by superimposition\_selection\_string is completely independent from the atom\_selection\_string atoms, as it can be a subset or superset of that, although it must refer to the same topology.

\textbf{Attributes}
\begin{description}
\item[{\emph{topology\_filename}}] \leavevmode{[}str{]}
Topology file name.

\item[{\emph{trajectory\_filename}}] \leavevmode{[}str{]}
Trajectory file name. If more then one are specified, it is a list of comma-separated names (e.g. ``traj1.xtc,traj2.xtc'')

\item[{\emph{universe}}] \leavevmode{[}MDAnalysis.Universe{]}
Universe object containing the original trajectory(es) and all the atoms in the topology.

\item[{\emph{frame\_interval}}] \leavevmode{[}int{]}
Keep only one frame every frame\_interval (see the package or module description)

\item[{\emph{atom\_selection\_string}}] \leavevmode{[}str{]}
Atom selection string in the MDAnalysis format (see \href{http://mdanalysis.googlecode.com/git/package/doc/html/documentation\_pages/selections.html}{http://mdanalysis.googlecode.com/git/package/doc/html/documentation\_pages/selections.html})

\item[{\emph{atom\_selection}}] \leavevmode{[}MDAnalysis.core.AtomGroup{]}
MDAnalysis atom selection, which corresponds to the selection defined by atom\_selection\_string on universe

\item[{\emph{coordinates}}] \leavevmode{[}(x,N,3) numpy.array{]}
Array of coordinate which will be used in the calculations, where x is the number of frames and N is the number of atoms. Notice that these coordinates may be different from those of universe, because of the atom\_selection and frame\_interval.

\item[{\emph{superimposition\_selection\_string}}] \leavevmode{[}str{]}
Analogous to atom\_selection\_string, but related to the subset of atoms that will be used for 3D superimposition.

\item[{\emph{superimposition\_selection}}] \leavevmode{[}MDAnalysis.core.AtomGroup{]}
Analogous to atom\_selection, but related to the subset of atoms that will be used for 3D superimposition.

\item[{\emph{superimposition\_coordinates}}] \leavevmode{[}(x,N,3) numpy.array{]}
Analogous to coordinates, but related to the subset of atoms that will be used for 3D superimposition.

\end{description}
\index{align() (encore.Ensemble.Ensemble method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.Ensemble.Ensemble.align}\pysiglinewithargsret{\bfcode{align}}{\emph{reference=None}, \emph{weighted=True}}{}
Least-square superimposition of the Ensemble coordinates to a reference structure.

\textbf{Arguments:}
\begin{description}
\item[{\emph{reference}}] \leavevmode{[}None or MDAnalysis.Universe{]}
Reference structure on which those belonging to the Ensemble will be fitted upon.
It must have the same topology as the Ensemble topology.
If reference is None, the structure in the first frame of the ensemble will be used as reference.

\item[{\emph{weighted}}] \leavevmode{[}bool{]}
Whether to perform weighted superimposition or not

\end{description}

\end{fulllineitems}

\index{get\_coordinates() (encore.Ensemble.Ensemble method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.Ensemble.Ensemble.get_coordinates}\pysiglinewithargsret{\bfcode{get\_coordinates}}{\emph{subset\_selection\_string=None}}{}
Get a set of coordinates from Universe.

\textbf{Arguments:}
\begin{description}
\item[{\emph{subset\_selection\_string}}] \leavevmode{[}None or str{]}
Selection string that selects the universe atoms whose coordinates have to be returned. The frame\_interval will be automatically applied.
If the argument is None,  the atoms defined in the atom\_selection\_string will be considered.

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{coordinates}}] \leavevmode{[}(x,N,3) numpy array{]}
The requested array of coordinates.

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\section{encore.confdistmatrix module}
\label{index:encore-confdistmatrix-module}\label{index:module-encore.confdistmatrix}\index{encore.confdistmatrix (module)}

\subsection{Distance Matrix calculation --- \texttt{MDAnalysis.analysis.ensemble.confdistmatrix}}
\label{index:distance-matrix-calculation-mdanalysis-analysis-ensemble-confdistmatrix}
The module contains a base class to easily compute, using parallelization and shared memory, matrices of conformational distance between the structures stored in an Ensemble.
A class to compute an RMSD matrix in such a way is also available.
\index{ConformationalDistanceMatrixGenerator (class in encore.confdistmatrix)}

\begin{fulllineitems}
\phantomsection\label{index:encore.confdistmatrix.ConformationalDistanceMatrixGenerator}\pysigline{\strong{class }\code{encore.confdistmatrix.}\bfcode{ConformationalDistanceMatrixGenerator}}
Base class for conformational distance matrices generator between array of coordinates. Work for single matrix elements is performed by the private \_simple\_worker and \_fitter\_worker methods, which respectively do or don't perform pairwise alignment before calculating the distance metric. The class efficiently and automatically spans work over a prescribed number of cores, while keeping both input coordinates and the output matrix as shared memory. If logging level is low enough, a progress bar of the whole process is printed out. This class acts as a functor.
\index{run() (encore.confdistmatrix.ConformationalDistanceMatrixGenerator method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.confdistmatrix.ConformationalDistanceMatrixGenerator.run}\pysiglinewithargsret{\bfcode{run}}{\emph{ensemble}, \emph{ncores=None}, \emph{pairwise\_align=False}, \emph{align\_subset\_coordinates=None}, \emph{mass\_weighted=True}, \emph{metadata=True}}{}
Run the conformational distance matrix calculation.

\textbf{Arguments:}
\begin{description}
\item[{\emph{ensemble}}] \leavevmode{[}encore.Ensemble.Ensemble object{]}
Ensemble object for which the conformational distance matrix will be computed.

\item[{\emph{pairwise\_align}}] \leavevmode{[}bool{]}
Whether to perform pairwise alignment between conformations

\item[{\emph{align\_subset\_coordinates}}] \leavevmode{[}numpy.array or None{]}
Use these coordinates for superimposition instead of those from ensemble.superimposition\_coordinates

\item[{\emph{mass\_weighted}}] \leavevmode{[}bool{]}
Whether to perform mass-weighted superimposition and metric calculation

\item[{\emph{metadata}}] \leavevmode{[}bool{]}
Whether to build a metadata dataset for the calculated matrix

\item[{\emph{ncores}}] \leavevmode{[}int{]}
Number of cores to be used for parallel calculation

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{cond\_dist\_matrix}}] \leavevmode{[}encore.utils.TriangularMatrix object{]}
Conformational distance matrix in triangular representation.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{MinusRMSDMatrixGenerator (class in encore.confdistmatrix)}

\begin{fulllineitems}
\phantomsection\label{index:encore.confdistmatrix.MinusRMSDMatrixGenerator}\pysigline{\strong{class }\code{encore.confdistmatrix.}\bfcode{MinusRMSDMatrixGenerator}}
Bases: {\hyperref[index:encore.confdistmatrix.ConformationalDistanceMatrixGenerator]{\code{encore.confdistmatrix.ConformationalDistanceMatrixGenerator}}}

-RMSD Matrix calculator. See encore.confdistmatrix.RMSDMatrixGenerator for details.

\end{fulllineitems}

\index{RMSDMatrixGenerator (class in encore.confdistmatrix)}

\begin{fulllineitems}
\phantomsection\label{index:encore.confdistmatrix.RMSDMatrixGenerator}\pysigline{\strong{class }\code{encore.confdistmatrix.}\bfcode{RMSDMatrixGenerator}}
Bases: {\hyperref[index:encore.confdistmatrix.ConformationalDistanceMatrixGenerator]{\code{encore.confdistmatrix.ConformationalDistanceMatrixGenerator}}}

RMSD Matrix calculator. Simple workers doesn't perform fitting, while fitter worker does.

\end{fulllineitems}



\section{encore.covariance module}
\label{index:module-encore.covariance}\label{index:encore-covariance-module}\index{encore.covariance (module)}

\subsection{Covariance calculation --- \texttt{encore.covariance}}
\label{index:covariance-calculation-encore-covariance}
The module contains functions to estimate the covariance matrix of
an ensemble of structures.
\index{EstimatorML (class in encore.covariance)}

\begin{fulllineitems}
\phantomsection\label{index:encore.covariance.EstimatorML}\pysigline{\strong{class }\code{encore.covariance.}\bfcode{EstimatorML}}
Standard maximum likelihood estimator of the covariance matrix. 
The generated object acts as a functor.
\index{calculate() (encore.covariance.EstimatorML method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.covariance.EstimatorML.calculate}\pysiglinewithargsret{\bfcode{calculate}}{\emph{coordinates}, \emph{reference\_coordinates=None}}{}
\textbf{Arguments:}
\begin{description}
\item[{\emph{coordinates}}] \leavevmode{[}numpy.array{]}
Flattened array of coordiantes

\item[{\emph{reference\_coordinates}}] \leavevmode{[}numpy.array {]}
Optional reference to use instead of mean

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{cov\_mat}}] \leavevmode{[}numpy.array{]}
Estimate of  covariance matrix

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{EstimatorShrinkage (class in encore.covariance)}

\begin{fulllineitems}
\phantomsection\label{index:encore.covariance.EstimatorShrinkage}\pysiglinewithargsret{\strong{class }\code{encore.covariance.}\bfcode{EstimatorShrinkage}}{\emph{shrinkage\_parameter=None}}{}
Shrinkage estimator of the covariance matrix using the method described in

Improved Estimation of the Covariance Matrix of Stock Returns With an Application 
to Portfolio Selection. Ledoit, O.; Wolf, M., Journal of Empirical Finance, 10, 5, 2003

This implementation is based on the matlab code made available by Olivier Ledoit on
his website:

\href{http://www.ledoit.net/ole2\_abstract.htm}{http://www.ledoit.net/ole2\_abstract.htm}

The generated object acts as a functor.
\index{calculate() (encore.covariance.EstimatorShrinkage method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.covariance.EstimatorShrinkage.calculate}\pysiglinewithargsret{\bfcode{calculate}}{\emph{coordinates}, \emph{reference\_coordinates=None}}{}
\textbf{Arguments:}
\begin{description}
\item[{\emph{coordinates}}] \leavevmode{[}numpy.array{]}
Flattened array of coordiantes

\item[{\emph{reference\_coordinates}: numpy.array}] \leavevmode
Optional reference to use instead of mean

\end{description}

\textbf{Returns}:
\begin{description}
\item[{\emph{cov\_mat}}] \leavevmode{[}nump.array{]}
Covariance matrix

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{covariance\_matrix() (in module encore.covariance)}

\begin{fulllineitems}
\phantomsection\label{index:encore.covariance.covariance_matrix}\pysiglinewithargsret{\code{encore.covariance.}\bfcode{covariance\_matrix}}{\emph{ensemble}, \emph{estimator=\textless{}encore.covariance.EstimatorShrinkage instance at 0x2f4c170\textgreater{}}, \emph{mass\_weighted=True}, \emph{reference=None}, \emph{start=0}, \emph{end=None}}{}
Calculates (optionally mass weighted) covariance matrix

\textbf{Arguments:}
\begin{description}
\item[{\emph{ensemble}}] \leavevmode{[}Ensemble object{]}
The structural ensemble

\item[{\emph{estimator}}] \leavevmode{[}MLEstimator or ShrinkageEstimator object{]}
Which estimator type to use (maximum likelihood, shrinkage). This object is required to have a \_\_call\_\_ function defined.

\item[{\emph{mass\_weighted}}] \leavevmode{[}bool{]}
Whether to do a mass-weighted analysis

\item[{\emph{reference}}] \leavevmode{[}MDAnalysis.Universe object{]}
Use the distances to a specific reference structure rather than the distance to the mean.

\end{description}

\textbf{Returns:}
\begin{description}
\item[{cov\_mat}] \leavevmode{[}numpy.array{]}
Covariance matrix

\end{description}

\end{fulllineitems}



\section{encore.similarity module}
\label{index:encore-similarity-module}\label{index:module-encore.similarity}\index{encore.similarity (module)}

\subsection{Ensemble similarity calculations --- \texttt{encore.similarity}}
\label{index:ensemble-similarity-calculations-encore-similarity}
The module contains implementations of similary measures between
protein ensembles described in:
\begin{quote}

Similarity Measures for Protein Ensembles. Lindorff-Larsen, K.; 
Ferkinghoff-Borg, J. PLoS ONE 2009, 4, e4203.
\end{quote}
\index{clustering\_ensemble\_similarity() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.clustering_ensemble_similarity}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{clustering\_ensemble\_similarity}}{\emph{cc}, \emph{ens1}, \emph{ens1\_id}, \emph{ens2}, \emph{ens2\_id}}{}
Clustering ensemble similarity: calculate the probability densities from the clusters and calculate discrete Jensen-Shannon divergence.

\textbf{Arguments:}
\begin{description}
\item[{\emph{cc}}] \leavevmode{[}encore.ClustersCollection {]}
Collection from cluster calculated by a clustering algorithm (e.g. Affinity propagation)

\item[{\emph{ens1}}] \leavevmode{[}encore.Ensemble{]}
First ensemble to be used in comparison

\item[{\emph{ens2}}] \leavevmode{[}encore.Ensemble{]}
Second ensemble to be used in comparison

\item[{\emph{ens1\_id}}] \leavevmode{[}int{]}
First ensemble id as detailed in the ClustersCollection metadata

\item[{\emph{ens2\_id}}] \leavevmode{[}int{]}
Second ensemble id as detailed in the ClustersCollection metadata

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{djs}}] \leavevmode{[}float{]}
Jensen-Shannon divergence between the two ensembles, as calculated by the clustering ensemble similarity method

\end{description}

\end{fulllineitems}

\index{cumulative\_clustering\_ensemble\_similarity() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.cumulative_clustering_ensemble_similarity}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{cumulative\_clustering\_ensemble\_similarity}}{\emph{cc}, \emph{ens1}, \emph{ens1\_id}, \emph{ens2}, \emph{ens2\_id}, \emph{ens1\_id\_min=1}, \emph{ens2\_id\_min=1}}{}
Calculate clustering ensemble similarity between joined ensembles. This means that, after clustering has been performed, some ensembles are merged and the dJS is calculated between the probability distributions of the two clusters groups. In particular, the two ensemble groups are defined by their ensembles id: one of the two joined ensembles will comprise all the ensembles with id {[}ens1\_id\_min, ens1\_id{]}, and the other ensembles will comprise all the ensembles with id {[}ens2\_id\_min, ens2\_id{]}.

\textbf{Arguments:}
\begin{quote}
\begin{description}
\item[{\emph{cc}}] \leavevmode{[}encore.ClustersCollection{]}
Collection from cluster calculated by a clustering algorithm (e.g. Affinity propagation)

\item[{\emph{ens1}}] \leavevmode{[}encore.Ensemble{]}
First ensemble to be used in comparison

\item[{\emph{ens2}}] \leavevmode{[}encore.Ensemble{]}
Second ensemble to be used in comparison

\item[{\emph{ens1\_id}}] \leavevmode{[}int{]}
First ensemble id as detailed in the ClustersCollection metadata

\item[{\emph{ens2\_id}}] \leavevmode{[}int{]}
Second ensemble id as detailed in the ClustersCollection metadata

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{djs}}] \leavevmode{[}float{]}
Jensen-Shannon divergence between the two ensembles, as calculated by the clustering ensemble similarity method

\end{description}
\end{quote}

\end{fulllineitems}

\index{cumulative\_gen\_kde\_pdfs() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.cumulative_gen_kde_pdfs}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{cumulative\_gen\_kde\_pdfs}}{\emph{embedded\_space}, \emph{ensemble\_assignment}, \emph{nensembles}, \emph{nsamples=None}, \emph{ens\_id\_min=1}, \emph{ens\_id\_max=None}}{}~\begin{quote}

Generate Kernel Density Estimates (KDE) from embedded spaces and elaborate the coordinates for later use. However, consider more than one ensemble as the space on which the KDE will be generated. In particular, will use ensembles with ID {[}ens\_id\_min, ens\_id\_max{]}.
\end{quote}

\textbf{Arguments:}
\begin{description}
\item[{\emph{embedded\_space}}] \leavevmode{[}numpy.array{]}
Array containing the coordinates of the embedded space

\item[{\emph{ensemble\_assignment}}] \leavevmode{[}numpy.array{]}
array containing one int per ensemble conformation. These allow to distinguish, in the complete embedded space, which conformations belong to each ensemble. For instance if ensemble\_assignment is {[}1,1,1,1,2,2{]}, it means that the first four conformations belong to ensemble 1 and the last two to ensemble 2

\item[{\emph{nesensembles}}] \leavevmode{[}int{]}
Number of ensembles

\item[{{\color{red}\bfseries{}{}`}nsamples}] \leavevmode{[}int {]}
Samples to be drawn from the ensembles. Will be required in a later stage in order to calculate dJS.{}`

\item[{\emph{ens\_id\_min}}] \leavevmode{[}int {]}
Minimum ID of the ensemble to be considered; see description

\item[{\emph{ens\_id\_max}}] \leavevmode{[}int{]}
Maximum ID of the ensemble to be considered; see description

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{kdes}}] \leavevmode{[}scipy.stats.gaussian\_kde{]}
KDEs calculated from ensembles

\item[{\emph{resamples}}] \leavevmode{[}list of numpy.array{]}
For each KDE, draw samples according to the probability distribution of the kde mixture model

\item[{\emph{embedded\_ensembles}}] \leavevmode{[}list of numpy.array{]}
List of numpy.array containing, each one, the elements of the embedded space belonging to a certain ensemble

\end{description}

\end{fulllineitems}

\index{dimred\_ensemble\_similarity() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.dimred_ensemble_similarity}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{dimred\_ensemble\_similarity}}{\emph{kde1}, \emph{resamples1}, \emph{kde2}, \emph{resamples2}, \emph{ln\_P1\_exp\_P1=None}, \emph{ln\_P2\_exp\_P2=None}, \emph{ln\_P1P2\_exp\_P1=None}, \emph{ln\_P1P2\_exp\_P2=None}}{}
Calculate the Jensen-Shannon divergence according the the Dimensionality reduction method. In this case, we have continuous probability densities we have to integrate over the measureable space. Our target is calculating Kullback-Liebler, which is defined as:
\begin{gather}
\begin{split}D_{KL}(P(x) || Q(x)) = \int_{-\infty}^{\infty}P(x_i) ln(P(x_i)/Q(x_i)) = \langle{}ln(P(x))\rangle{}_P - \langle{}ln(Q(x))\rangle{}_P\end{split}\notag
\end{gather}
where the \(\langle{}.\rangle{}_P\) denotes an expectation calculated under the 
distribution P. We can, thus, just estimate the expectation values of the components to get an estimate of dKL.
Since the Jensen-Shannon distance is actually  more complex, we need to estimate four expectation values:
\begin{gather}
\begin{split}\langle{}log(P(x))\rangle{}_P\end{split}\notag\\\begin{split}\langle{}log(Q(x))\rangle{}_Q\end{split}\notag\\\begin{split}\langle{}log(0.5*(P(x)+Q(x)))\rangle{}_P\end{split}\notag\\\begin{split}\langle{}log(0.5*(P(x)+Q(x)))\rangle{}_Q\end{split}\notag
\end{gather}
\textbf{Arguments:}
\begin{description}
\item[{\emph{kde1}}] \leavevmode{[}scipy.stats.gaussian\_kde{]}
Kernel density estimation for ensemble 1

\item[{\emph{resamples1}}] \leavevmode{[}numpy.array{]}
Samples drawn according do kde1. Will be used as samples to calculate the expected values according to `P' as detailed before.

\item[{\emph{kde2}}] \leavevmode{[}scipy.stats.gaussian\_kde{]}
Kernel density estimation for ensemble 2

\item[{\emph{resamples2}}] \leavevmode{[}numpy.array{]}
Samples drawn according do kde2. Will be used as sample to calculate the expected values according to `Q' as detailed before.

\item[{\emph{ln\_P1\_exp\_P1}}] \leavevmode{[}float or None{]}
Use this value for \(\langle{}log(P(x))\rangle{}_P\); if None, calculate it instead

\item[{\emph{ln\_P2\_exp\_P2}}] \leavevmode{[}float or None{]}
Use this value for \(\langle{}log(Q(x))\rangle{}_Q\); if None, calculate it instead

\item[{\emph{ln\_P1P2\_exp\_P1}}] \leavevmode{[}float or None{]}
Use this value for \(\langle{}log(0.5*(P(x)+Q(x)))\rangle{}_P\);  if None, calculate it instead

\item[{\emph{ln\_P1P2\_exp\_P1}}] \leavevmode{[}float or None{]}
Use this value for \(\langle{}log(0.5*(P(x)+Q(x)))\rangle{}_Q\); if None, calculate it instead

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{djs}}] \leavevmode{[}float{]}
Jensen-Shannon divergence calculated according to the dimensionality reduction method

\end{description}

\end{fulllineitems}

\index{discrete\_jensen\_shannon\_divergence() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.discrete_jensen_shannon_divergence}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{discrete\_jensen\_shannon\_divergence}}{\emph{pA}, \emph{pB}}{}
Jensen-Shannon divergence between discrete probability distributions.

\textbf{Arguments:}
\begin{quote}
\begin{description}
\item[{\emph{pA}}] \leavevmode{[}iterable of floats{]}
First discrete probability density function

\item[{\emph{pB}}] \leavevmode{[}iterable of floats{]}
Second discrete probability density function

\end{description}
\end{quote}

\textbf{Returns:}
\begin{quote}
\begin{description}
\item[{\emph{djs}}] \leavevmode{[}float{]}
Discrete Jensen-Shannon divergence

\end{description}
\end{quote}

\end{fulllineitems}

\index{discrete\_kullback\_leibler\_divergence() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.discrete_kullback_leibler_divergence}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{discrete\_kullback\_leibler\_divergence}}{\emph{pA}, \emph{pB}}{}
Kullback-Leibler divergence between discrete probability distribution. Notice that since this measure is not symmetric  \(d_{KL}(p_A,p_B) != d_{KL}(p_B,p_A)\)

\textbf{Arguments:}
\begin{quote}
\begin{description}
\item[{\emph{pA}}] \leavevmode{[}iterable of floats{]}
First discrete probability density function

\item[{\emph{pB}}] \leavevmode{[}iterable of floats{]}
Second discrete probability density function

\end{description}
\end{quote}

\textbf{Returns:}
\begin{quote}
\begin{description}
\item[{\emph{dkl}}] \leavevmode{[}float{]}
Discrete Kullback-Liebler divergence

\end{description}
\end{quote}

\end{fulllineitems}

\index{gen\_kde\_pdfs() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.gen_kde_pdfs}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{gen\_kde\_pdfs}}{\emph{embedded\_space}, \emph{ensemble\_assignment}, \emph{nensembles}, \emph{nsamples=None}, \emph{**kwargs}}{}~\begin{quote}

Generate Kernel Density Estimates (KDE) from embedded spaces and elaborate the coordinates for later use.
\end{quote}

\textbf{Arguments:}
\begin{description}
\item[{\emph{embedded\_space}}] \leavevmode{[}numpy.array{]}
Array containing the coordinates of the embedded space

\item[{\emph{ensemble\_assignment}}] \leavevmode{[}numpy.array{]}
Array containing one int per ensemble conformation. These allow to distinguish, in the complete embedded space, which conformations belong to each ensemble. For instance if ensemble\_assignment is {[}1,1,1,1,2,2{]}, it means that the first four conformations belong to ensemble 1 and the last two to ensemble 2

\item[{\emph{nesensembles}}] \leavevmode{[}int{]}
Number of ensembles

\end{description}

\emph{nsamples} : int samples to be drawn from the ensembles. Will be required in a later stage in order to calculate dJS.{}`

\textbf{Returns:}
\begin{description}
\item[{\emph{kdes}}] \leavevmode{[}scipy.stats.gaussian\_kde{]}
KDEs calculated from ensembles

\item[{\emph{resamples}}] \leavevmode{[}list of numpy.array{]}
For each KDE, draw samples according to the probability distribution of the KDE mixture model

\item[{\emph{embedded\_ensembles}}] \leavevmode{[}list of numpy.array{]}
List of numpy.array containing, each one, the elements of the embedded space belonging to a certain ensemble

\end{description}

\end{fulllineitems}

\index{harmonic\_ensemble\_similarity() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.harmonic_ensemble_similarity}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{harmonic\_ensemble\_similarity}}{\emph{ensemble1=None}, \emph{ensemble2=None}, \emph{sigma1=None}, \emph{sigma2=None}, \emph{x1=None}, \emph{x2=None}, \emph{mass\_weighted=True}, \emph{covariance\_estimator=\textless{}encore.covariance.EstimatorShrinkage instance at 0x33d8170\textgreater{}}}{}
Calculate the harmonic ensemble similarity measure
as defined in
\begin{quote}

Similarity Measures for Protein Ensembles. Lindorff-Larsen, K.; 
Ferkinghoff-Borg, J. PLoS ONE 2009, 4, e4203.
\end{quote}

\textbf{Arguments:}
\begin{quote}
\begin{description}
\item[{\emph{ensemble1}}] \leavevmode{[}encore.Ensemble or None{]}
First ensemble to be compared. If this is None, sigma1 and x1 must be provided.

\item[{\emph{ensemble2}}] \leavevmode{[}encore.Ensemble or None{]}
Second ensemble to be compared. If this is None, sigma2 and x2 must be provided.

\item[{\emph{sigma1}}] \leavevmode{[}numpy.array{]}
Covariance matrix for the first ensemble. If this None, calculate it from ensemble1 using covariance\_estimator

\item[{\emph{sigma2}}] \leavevmode{[}numpy.array{]}
Covariance matrix for the second ensemble. If this None, calculate it from ensemble1 using covariance\_estimator

\item[{\emph{x1}: numpy.array }] \leavevmode
Mean for the estimated normal multivariate distribution of the first ensemble. If this is None, calculate it from ensemble1

\item[{\emph{x2}: numpy.array}] \leavevmode
Mean for the estimated normal multivariate distribution of the first ensemble.. If this is None, calculate it from ensemble2

\item[{\emph{mass\_weighted}}] \leavevmode{[}bool{]}
Whether to perform mass-weighted covariance matrix estimation

\item[{\emph{covariance\_estimator}}] \leavevmode{[}either EstimatorShrinkage or EstimatorML objects{]}
Which covariance estimator to use

\end{description}
\end{quote}

\textbf{Returns:}
\begin{quote}
\begin{description}
\item[{\emph{dhes}}] \leavevmode{[}float{]}
harmonic similarity measure

\end{description}
\end{quote}

\end{fulllineitems}

\index{write\_output() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.write_output}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{write\_output}}{\emph{matrix}, \emph{base\_fname=None}, \emph{header='`}, \emph{suffix='`}, \emph{extension='dat'}}{}~\begin{quote}

Write output matrix with a nice format, to stdout and optionally a file.
\end{quote}

\textbf{Arguments:}
\begin{description}
\item[{\emph{matrix}}] \leavevmode{[}encore.utils.TriangularMatrix{]}
Matrix containing the values to be printed

\item[{\emph{base\_fname}}] \leavevmode{[}str{]}
Basic filename for output. If None, no files will be written, and the matrix will be just printed on screen

\item[{\emph{header}}] \leavevmode{[}str{]}
Line to be written just before the matrix

\item[{\emph{suffix}}] \leavevmode{[}str {]}
String to be concatenated to basename, in order to get the final file name

\item[{\emph{extension}}] \leavevmode{[}str {]}
Extension for the output file

\end{description}

\end{fulllineitems}

\index{write\_output\_line() (in module encore.similarity)}

\begin{fulllineitems}
\phantomsection\label{index:encore.similarity.write_output_line}\pysiglinewithargsret{\code{encore.similarity.}\bfcode{write\_output\_line}}{\emph{value}, \emph{fhandler=None}, \emph{suffix='`}, \emph{label='win.'}, \emph{number=0}, \emph{rawline=None}}{}~\begin{quote}

Write a line of data with a fixed format to standard output and optionally file. The line will be appended or written to a file object.
\end{quote}

The format is (in the Python str.format specification language): `\{:s\}\{:d\}      \{:.3f\}', with the first element being the label, the second being
a number that identifies the data point, and the third being the number itself. For instance:

win.3   0.278

\textbf{Arguments:}
\begin{description}
\item[{\emph{value}}] \leavevmode{[}float{]}
Value to be printed.

\item[{\emph{fhandler}}] \leavevmode{[}file object{]}
File object in which the line will be written. if None, nothing will be written to file, and the value will be just printed on screen

\item[{\emph{label}}] \leavevmode{[}str{]}
Label to be written before the data

\item[{\emph{number}}] \leavevmode{[}int {]}
Number that identifies the data being written in this line.

\item[{\emph{rawline}}] \leavevmode{[}str{]}
If rawline is not None, write rawline to fhandler instead of the formatted number line. rawline can be any arbitrary string.

\end{description}

\end{fulllineitems}



\section{encore.utils module}
\label{index:encore-utils-module}\label{index:module-encore.utils}\index{encore.utils (module)}\index{AllowUnrecognizedOptionParser (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.AllowUnrecognizedOptionParser}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{AllowUnrecognizedOptionParser}}{\emph{usage=None}, \emph{option\_list=None}, \emph{option\_class=\textless{}class optparse.Option at 0xc41808\textgreater{}}, \emph{version=None}, \emph{conflict\_handler='error'}, \emph{description=None}, \emph{formatter=None}, \emph{add\_help\_option=True}, \emph{prog=None}, \emph{epilog=None}}{}
Bases: \code{optparse.OptionParser}

Parser allowing unknown options. Note that only AmbiguousOptionError
is caught, meaning that unexpected arguments to known options still give
rise to an error.

\end{fulllineitems}

\index{AnimatedProgressBar (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.AnimatedProgressBar}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{AnimatedProgressBar}}{\emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[index:encore.utils.ProgressBar]{\code{encore.utils.ProgressBar}}}

Extends ProgressBar to allow you to use it straighforward on a script.
Accepts an extra keyword argument named \emph{stdout} (by default use sys.stdout).
The progress status may be send to any file-object.
\index{show\_progress() (encore.utils.AnimatedProgressBar method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.AnimatedProgressBar.show_progress}\pysiglinewithargsret{\bfcode{show\_progress}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{OptionGroup (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.OptionGroup}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{OptionGroup}}{\emph{parser}, \emph{title}, \emph{description=None}}{}
Bases: \code{optparse.OptionGroup}

A wrapper for a group of options. Stores the args and kwargs options
used to create options within the group, so that duplicates can be
made
\index{add\_option() (encore.utils.OptionGroup method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.OptionGroup.add_option}\pysiglinewithargsret{\bfcode{add\_option}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{duplicate() (encore.utils.OptionGroup method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.OptionGroup.duplicate}\pysiglinewithargsret{\bfcode{duplicate}}{\emph{index}}{}
Make a copy of the entire group. Any occurrence of ``\%(index)s''
within any of the arguments will be replaced by the provided index

\end{fulllineitems}


\end{fulllineitems}

\index{OptionGroups (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.OptionGroups}\pysigline{\strong{class }\code{encore.utils.}\bfcode{OptionGroups}}
Wrapper for the creation of new groups, making it possible to reuse
OptionGroup definitions in different parsers (which is normally not
possible since they are bound to a specific parser.
\index{add\_group() (encore.utils.OptionGroups method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.OptionGroups.add_group}\pysiglinewithargsret{\bfcode{add\_group}}{\emph{title}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ParallelCalculation (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ParallelCalculation}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{ParallelCalculation}}{\emph{ncores}, \emph{function}, \emph{args={[}{]}}, \emph{kwargs=None}}{}
Generic parallel calculation class. Can use arbitrary functions,
arguments to functions and kwargs to functions.
\begin{description}
\item[{\textbf{Attributes:}}] \leavevmode\begin{description}
\item[{\emph{ncores}}] \leavevmode{[}int {]}
Number of cores to be used for parallel calculation

\item[{\emph{function}}] \leavevmode{[}callable object{]}
Function to be run in parallel.

\item[{\emph{args}}] \leavevmode{[}list of tuples{]}
Each tuple contains the arguments that will be passed to function(). This means that a call to function() is performed for each tuple. function is called as function({\color{red}\bfseries{}*}args, {\color{red}\bfseries{}**}kwargs). Runs are distributed on the requested numbers of cores.

\item[{\emph{kwargs}}] \leavevmode{[}list of dicts{]}
Each tuple contains the named arguments that will be passed to function, similarly as described for the args attribute.

\item[{\emph{nruns}}] \leavevmode{[}int{]}
Number of runs to be performed. Must be equal to len(args) and len(kwargs).

\end{description}

\end{description}
\index{run() (encore.utils.ParallelCalculation method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ParallelCalculation.run}\pysiglinewithargsret{\bfcode{run}}{}{}
Run parallel calculation.

\textbf{Returns:}
\begin{description}
\item[{\emph{results}}] \leavevmode{[}tuple of ordered tuples (int, object){]}
int is the number of the calculation corresponding to a certain argument in the args list, and object is the result of corresponding calculation. For instance, in (3, output), output is the return of function(*args{[}3{]}, **kwargs{[}3{]}).

\end{description}

\end{fulllineitems}

\index{worker() (encore.utils.ParallelCalculation method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ParallelCalculation.worker}\pysiglinewithargsret{\bfcode{worker}}{\emph{q}, \emph{results}}{}
Generic worker. Will run function with the prescribed args and kwargs.

\textbf{Arguments:}
\begin{description}
\item[{\emph{q}}] \leavevmode{[}multiprocessing.Manager.Queue object{]}
work queue, from which the worker fetches arguments and messages

\item[{\emph{results}}] \leavevmode{[}multiprocessing.Manager.Queue object{]}
results queue, where results are put after each calculation is finished

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{ParserPhase (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ParserPhase}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{ParserPhase}}{\emph{option\_groups}, \emph{add\_help\_option=True}, \emph{allow\_unrecognized=False}, \emph{usage='`}}{}
Wrapper for a parser for a single phase. Takes a list of option groups as arguments
\index{add\_option\_groups() (encore.utils.ParserPhase method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ParserPhase.add_option_groups}\pysiglinewithargsret{\bfcode{add\_option\_groups}}{\emph{option\_groups}, \emph{copies=1}}{}
\end{fulllineitems}

\index{parse() (encore.utils.ParserPhase method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ParserPhase.parse}\pysiglinewithargsret{\bfcode{parse}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{PassThroughOptionParser (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.PassThroughOptionParser}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{PassThroughOptionParser}}{\emph{usage=None}, \emph{option\_list=None}, \emph{option\_class=\textless{}class optparse.Option at 0xc41808\textgreater{}}, \emph{version=None}, \emph{conflict\_handler='error'}, \emph{description=None}, \emph{formatter=None}, \emph{add\_help\_option=True}, \emph{prog=None}, \emph{epilog=None}}{}
Bases: \code{optparse.OptionParser}

An unknown option pass-through implementation of OptionParser.

When unknown arguments are encountered, bundle with largs and try again,
until rargs is depleted.

sys.exit(status) will still be called if a known argument is passed
incorrectly (e.g. missing arguments or bad argument types, etc.)

\end{fulllineitems}

\index{ProgressBar (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ProgressBar}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{ProgressBar}}{\emph{start=0}, \emph{end=10}, \emph{width=12}, \emph{fill='='}, \emph{blank='.'}, \emph{format='{[}\%(fill)s\textgreater{}\%(blank)s{]} \%(progress)s\%\%'}, \emph{incremental=True}}{}
Bases: \code{object}

Handle and draw a progress barr.  From \href{https://github.com/ikame/progressbar}{https://github.com/ikame/progressbar}
\index{reset() (encore.utils.ProgressBar method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ProgressBar.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Resets the current progress to the start point

\end{fulllineitems}

\index{update() (encore.utils.ProgressBar method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.ProgressBar.update}\pysiglinewithargsret{\bfcode{update}}{\emph{progress}}{}
Update the progress value instead of incrementing it

\end{fulllineitems}


\end{fulllineitems}

\index{Tee (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.Tee}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{Tee}}{\emph{*files}}{}
Simple class that writes to one or more file objects.

\textbf{Attributes:}
\begin{description}
\item[{\emph{files}}] \leavevmode{[}list of file objects{]}
File objects to be written to.

\end{description}
\index{write() (encore.utils.Tee method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.Tee.write}\pysiglinewithargsret{\bfcode{write}}{\emph{obj}}{}
Write string obj to all the file objects.

\textbf{Arguments}:
\begin{description}
\item[{\emph{obj}}] \leavevmode{[}str{]}
String to write to the file objects.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{TriangularMatrix (class in encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.TriangularMatrix}\pysiglinewithargsret{\strong{class }\code{encore.utils.}\bfcode{TriangularMatrix}}{\emph{size}, \emph{metadata=None}, \emph{loadfile=None}}{}
Triangular matrix class. This class is designed to provide a memory-efficient representation of a triangular matrix that still behaves as a square symmetric one. The class wraps a numpy.array object, in which data are memorized in row-major order. It also has few additional facilities to conveniently load/write a matrix from/to file. It can be accessed using the {[}{]} and () operators, similarly to a normal numpy array.

\textbf{Attributes:}
\begin{description}
\item[{\emph{ensemble}}] \leavevmode{[}int{]}
Size of the matrix (number of rows or number of columns)

\item[{\emph{metadata}}] \leavevmode{[}dict{]}
Metadata for the matrix (date of creation, name of author ...)

\end{description}
\index{loadz() (encore.utils.TriangularMatrix method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.TriangularMatrix.loadz}\pysiglinewithargsret{\bfcode{loadz}}{\emph{fname}}{}
Load matrix from the npz compressed numpy format.

\textbf{Arguments}:

\emph{fname} : str
Name of the file to be loaded.

\end{fulllineitems}

\index{savez() (encore.utils.TriangularMatrix method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.TriangularMatrix.savez}\pysiglinewithargsret{\bfcode{savez}}{\emph{fname}}{}
Save matrix in the npz compressed numpy format. Save metadata and data as well.

\textbf{Arguments}:

\emph{fname} : str
Name of the file to be saved.

\end{fulllineitems}

\index{square\_print() (encore.utils.TriangularMatrix method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.TriangularMatrix.square_print}\pysiglinewithargsret{\bfcode{square\_print}}{\emph{fname=None}, \emph{header=None}, \emph{label='ens.'}, \emph{justification=10}}{}
Print the triangular matrix as a symmetrical square matrix.
Also supports printing to a file (named fname).

\end{fulllineitems}

\index{trm\_print() (encore.utils.TriangularMatrix method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.TriangularMatrix.trm_print}\pysiglinewithargsret{\bfcode{trm\_print}}{\emph{justification=10}}{}
Print the triangular matrix as triangular

\end{fulllineitems}


\end{fulllineitems}

\index{trm\_indeces() (in module encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.trm_indeces}\pysiglinewithargsret{\code{encore.utils.}\bfcode{trm\_indeces}}{\emph{a}, \emph{b}}{}
Generate (i,j) indeces of a triangular matrix, between elements a and b. The matrix size is automatically determined from the number of elements.
For instance: trm\_indexes((0,0),(2,1)) yields (0,0) (1,0) (1,1) (2,0) (2,1).

\textbf{Arguments:}
\begin{description}
\item[{\emph{a}}] \leavevmode{[}(int i, int j) tuple{]}
starting matrix element.

\item[{\emph{b}}] \leavevmode{[}(int i, int j) tuple{]}
final matrix element.

\end{description}

\end{fulllineitems}

\index{trm\_indeces\_nodiag() (in module encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.trm_indeces_nodiag}\pysiglinewithargsret{\code{encore.utils.}\bfcode{trm\_indeces\_nodiag}}{\emph{n}}{}
generate (i,j) indeces of a triangular matrix of n rows (or columns), without diagonal (e.g. no elements (0,0),(1,1),...,(n,n))

\textbf{Arguments:}
\begin{description}
\item[{\emph{n}}] \leavevmode{[}int {]}
Matrix size

\end{description}

\end{fulllineitems}

\index{vararg\_callback() (in module encore.utils)}

\begin{fulllineitems}
\phantomsection\label{index:encore.utils.vararg_callback}\pysiglinewithargsret{\code{encore.utils.}\bfcode{vararg\_callback}}{\emph{option}, \emph{opt\_str}, \emph{value}, \emph{parser}}{}
A callback for the option parser allowing a variable number of arguments.

\end{fulllineitems}



\chapter{encore.clustering package}
\label{index:encore-clustering-package}

\section{Submodules}
\label{index:id7}

\section{encore.clustering.Cluster module}
\label{index:module-encore.clustering.Cluster}\label{index:encore-clustering-cluster-module}\index{encore.clustering.Cluster (module)}

\subsection{Ensemble representation --- \texttt{MDAnalysis.analysis.ensemble.ensemble}}
\label{index:id8}
The module contains the Cluster and ClusterCollection classes which are designed
to store results from clustering algorithms.
\index{Cluster (class in encore.clustering.Cluster)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.Cluster.Cluster}\pysiglinewithargsret{\strong{class }\code{encore.clustering.Cluster.}\bfcode{Cluster}}{\emph{elem\_list=None}, \emph{centroid=None}, \emph{idn=None}, \emph{metadata=None}}{}~\begin{quote}

Generic Cluster class for clusters with centroids.
\end{quote}

\textbf{Attributes}:
\begin{quote}
\begin{description}
\item[{\emph{id}}] \leavevmode{[}int{]}
Cluster ID number. Useful for the ClustersCollection class

\item[{\emph{metadata}}] \leavevmode{[}iterable{]}
dict of lists, containing metadata for the cluster elements. The iterable must return the same number of elements as those that belong to the cluster.

\item[{\emph{size}}] \leavevmode{[}int{]}
number of elements.

\item[{\emph{centroid}}] \leavevmode{[}element object{]}
cluster centroid.

\item[{\emph{elements}}] \leavevmode{[}numpy.array{]}
array containing the cluster elements.

\end{description}
\end{quote}
\index{add\_metadata() (encore.clustering.Cluster.Cluster method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.Cluster.Cluster.add_metadata}\pysiglinewithargsret{\bfcode{add\_metadata}}{\emph{name}, \emph{data}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ClustersCollection (class in encore.clustering.Cluster)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.Cluster.ClustersCollection}\pysiglinewithargsret{\strong{class }\code{encore.clustering.Cluster.}\bfcode{ClustersCollection}}{\emph{elements=None}, \emph{metadata=None}}{}
Clusters collection class; this class represents the results of a full clustering run. It stores a group of clusters defined as encore.clustering.Cluster objects.

\textbf{Attributes:}
\begin{description}
\item[{\emph{clusters}}] \leavevmode{[}list of Cluster objects{]}
clusters object which are part of the Cluster collection

\end{description}
\index{get\_centroids() (encore.clustering.Cluster.ClustersCollection method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.Cluster.ClustersCollection.get_centroids}\pysiglinewithargsret{\bfcode{get\_centroids}}{}{}
Get the centroids of the clusters

\textbf{Returns:}
\begin{description}
\item[{\emph{centroids}}] \leavevmode{[}list of cluster element objects{]}
list of cluster centroids

\end{description}

\end{fulllineitems}

\index{get\_ids() (encore.clustering.Cluster.ClustersCollection method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.Cluster.ClustersCollection.get_ids}\pysiglinewithargsret{\bfcode{get\_ids}}{}{}
Get the ID numbers of the clusters

\textbf{Returns:}
\begin{description}
\item[{\emph{ids}}] \leavevmode{[}list of int {]}
list of cluster ids

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\section{encore.clustering.affinityprop module}
\label{index:encore-clustering-affinityprop-module}\label{index:module-encore.clustering.affinityprop}\index{encore.clustering.affinityprop (module)}\index{AffinityPropagation (class in encore.clustering.affinityprop)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.affinityprop.AffinityPropagation}\pysigline{\strong{class }\code{encore.clustering.affinityprop.}\bfcode{AffinityPropagation}}
Affinity propagation clustering algorithm. This class is a Cython wrapper around the Affinity propagation algorithm, which is implement as a C library (see ap.c). The implemented algorithm is described in the paper:
\begin{quote}

Clustering by Passing Messages Between Data Points.
Brendan J. Frey and Delbert Dueck, University of Toronto
Science 315, 972–976, February 2007
\end{quote}
\index{run() (encore.clustering.affinityprop.AffinityPropagation method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.clustering.affinityprop.AffinityPropagation.run}\pysiglinewithargsret{\bfcode{run}}{\emph{self}, \emph{s}, \emph{preference}, \emph{double lam}, \emph{int max\_iterations}, \emph{int convergence}, \emph{int noise=1}}{}
\end{fulllineitems}


Run the clustering algorithm.
\begin{quote}

\textbf{Arguments:}
\begin{description}
\item[{\emph{s}}] \leavevmode{[}encore.utils.TriangularMatrix object{]}
Triangular matrix containing the similarity values for each pair of clustering elements. Notice that the current implementation does not allow for asymmetric values (i.e. similarity(a,b) is assumed to be equal to similarity(b,a))

\item[{\emph{preference}}] \leavevmode{[}numpy.array of floats or float{]}
Preference values, which the determine the number of clusters. If a single value is given, all the preference values are set to that. Otherwise, the list is used to set the preference values (one value per element, so the list must be of the same size as the number of elements)

\item[{\emph{lam}}] \leavevmode{[}float{]}
Floating point value that defines how much damping is applied to the solution at each iteration. Must be {]}0,1{]}

\item[{\emph{max\_iterations}}] \leavevmode{[}int{]}
Maximum number of iterations

\item[{\emph{convergence}}] \leavevmode{[}int{]}
Number of iterations in which the cluster centers must remain the same in order to reach convergence

\item[{\emph{noise}}] \leavevmode{[}int{]}
Whether to apply noise to the input s matrix, such there are no equal values. 1 is for yes, 0 is for no.

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{elements}}] \leavevmode{[}list of int or None{]}
List of cluster-assigned elements, which can be used by encore.utils.ClustersCollection to generate Cluster objects. See these classes for more details.

\end{description}
\end{quote}

\end{fulllineitems}



\chapter{encore.dimensionality\_reduction package}
\label{index:encore-dimensionality-reduction-package}

\section{Module contents}
\label{index:module-contents}\label{index:module-encore.dimensionality_reduction}\index{encore.dimensionality\_reduction (module)}\phantomsection\label{index:module-encore.dimensionality_reduction.stochasticproxembed}\index{encore.dimensionality\_reduction.stochasticproxembed (module)}\index{StochasticProximityEmbedding (class in encore.dimensionality\_reduction.stochasticproxembed)}

\begin{fulllineitems}
\phantomsection\label{index:encore.dimensionality_reduction.stochasticproxembed.StochasticProximityEmbedding}\pysigline{\strong{class }\code{encore.dimensionality\_reduction.stochasticproxembed.}\bfcode{StochasticProximityEmbedding}}~\begin{quote}

Stochastic proximity embedding dimensionality reduction algorithm. The algorithm implemented here is described in this paper:
\begin{quote}

Dmitrii N. Rassokhin, Dimitris K. Agrafiotis
A modified update rule for stochastic proximity embedding
Journal of Molecular Graphics and Modelling 22 (2003) 133–140
\end{quote}

This class is a Cython wrapper for a C implementation (see spe.c)
\index{run() (encore.dimensionality\_reduction.stochasticproxembed.StochasticProximityEmbedding method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.dimensionality_reduction.stochasticproxembed.StochasticProximityEmbedding.run}\pysiglinewithargsret{\bfcode{run}}{\emph{self}, \emph{s}, \emph{double rco}, \emph{int dim}, \emph{double maxlam}, \emph{double minlam}, \emph{int ncycle}, \emph{int nstep}, \emph{int stressfreq}}{}
\end{fulllineitems}


Run stochastic proximity embedding.
\begin{quote}

\textbf{Arguments:}
\begin{description}
\item[{\emph{s}}] \leavevmode{[}encore.utils.TriangularMatrix object{]}
Triangular matrix containing the distance values for each pair of elements in the original space.

\item[{\emph{rco}}] \leavevmode{[}float{]}
neighborhood distance cut-off

\item[{\emph{dim}}] \leavevmode{[}int{]}
number of dimensions for the embedded space

\item[{\emph{minlam}}] \leavevmode{[}float{]}
final learning parameter

\item[{\emph{maxlam}}] \leavevmode{[}float{]}
starting learning parameter

\item[{\emph{ncycle}}] \leavevmode{[}int{]}
number of cycles. Each cycle is composed of nstep steps. At the end of each cycle, the lerning parameter lambda is updated.

\item[{\emph{nstep}}] \leavevmode{[}int{]}
number of coordinate update steps for each cycle

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{space}}] \leavevmode{[}(float, numpy.array){]}
float is the final stress obtained; the array are the coordinates of the elements in the embedded space

\item[{\emph{stressfreq}}] \leavevmode{[}int{]}
calculate and report stress value every stressfreq cycle

\end{description}
\end{quote}
\end{quote}

\end{fulllineitems}

\index{kNNStochasticProximityEmbedding (class in encore.dimensionality\_reduction.stochasticproxembed)}

\begin{fulllineitems}
\phantomsection\label{index:encore.dimensionality_reduction.stochasticproxembed.kNNStochasticProximityEmbedding}\pysigline{\strong{class }\code{encore.dimensionality\_reduction.stochasticproxembed.}\bfcode{kNNStochasticProximityEmbedding}}~\begin{quote}

k-Nearest Neighbours Stochastic proximity embedding dimensionality reduction algorithm.
This is a variation of the SPE algorithm in which neighbourhood is not defined by a distance cut-off; instead, at each step, when a point is randomly chosen to perform coordinate updates, the coordinates of its k nearest neighbours are updated as well.
This class is a Cython wrapper for a C implementation (see spe.c)
\index{run() (encore.dimensionality\_reduction.stochasticproxembed.kNNStochasticProximityEmbedding method)}

\begin{fulllineitems}
\phantomsection\label{index:encore.dimensionality_reduction.stochasticproxembed.kNNStochasticProximityEmbedding.run}\pysiglinewithargsret{\bfcode{run}}{\emph{self}, \emph{s}, \emph{int kn}, \emph{int dim}, \emph{double maxlam}, \emph{double minlam}, \emph{int ncycle}, \emph{int nstep}, \emph{int stressfreq}}{}
\end{fulllineitems}


Run kNN-SPE.
\begin{quote}
\begin{quote}

\textbf{Arguments:}
\end{quote}
\begin{description}
\item[{\emph{s}}] \leavevmode{[}encore.utils.TriangularMatrix object{]}
Triangular matrix containing the distance values for each pair of elements in the original space.

\item[{\emph{kn}}] \leavevmode{[}int{]}
number of k points to be used as neighbours, in the original space

\item[{\emph{dim}}] \leavevmode{[}int{]}
number of dimensions for the embedded space

\item[{\emph{minlam}}] \leavevmode{[}float{]}
final learning parameter

\item[{\emph{maxlam}}] \leavevmode{[}float{]}
starting learning parameter

\item[{\emph{ncycle}}] \leavevmode{[}int{]}
number of cycles. Each cycle is composed of nstep steps. At the end of each cycle, the lerning parameter lambda is updated.

\item[{\emph{nstep}}] \leavevmode{[}int{]}
number of coordinate update steps for each cycle

\end{description}

\textbf{Returns:}
\begin{description}
\item[{\emph{space}}] \leavevmode{[}(float, numpy.array){]}
float is the final stress obtained; the array are the coordinates of the elements in the embedded space

\item[{\emph{stressfreq}}] \leavevmode{[}int{]}
calculate and report stress value every stressfreq cycle

\end{description}
\end{quote}
\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{e}
\item {\texttt{encore.clustering.affinityprop}}, \pageref{index:module-encore.clustering.affinityprop}
\item {\texttt{encore.clustering.Cluster}}, \pageref{index:module-encore.clustering.Cluster}
\item {\texttt{encore.confdistmatrix}}, \pageref{index:module-encore.confdistmatrix}
\item {\texttt{encore.covariance}}, \pageref{index:module-encore.covariance}
\item {\texttt{encore.dimensionality\_reduction}}, \pageref{index:module-encore.dimensionality_reduction}
\item {\texttt{encore.dimensionality\_reduction.stochasticproxembed}}, \pageref{index:module-encore.dimensionality_reduction.stochasticproxembed}
\item {\texttt{encore.Ensemble}}, \pageref{index:module-encore.Ensemble}
\item {\texttt{encore.similarity}}, \pageref{index:module-encore.similarity}
\item {\texttt{encore.utils}}, \pageref{index:module-encore.utils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
